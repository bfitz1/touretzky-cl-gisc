(defun complement-base (base)
  (cond ((equal base 'a) 't)
        ((equal base 't) 'a)
        ((equal base 'g) 'c)
        ((equal base 'c) 'g)))

(defun complement-strand (strand)
  (mapcar #'complement-base strand))

(defun make-double (strand)
  (mapcar #'list strand (complement-strand strand)))

;; Seems like a hash map would be pretty good here
(defun count-bases (strand)
  (let ((ad 0)
        (th 0)
        (gu 0)
        (cy 0)
        (bases (if (atom (first strand))
                   strand
                   (apply #'append strand))))
    (labels ((incf-base (b)
               (cond ((equal b 'a) (incf ad))
                     ((equal b 't) (incf th))
                     ((equal b 'g) (incf gu))
                     ((equal b 'c) (incf cy)))))
      (dolist (b bases (list (list 'a ad)
                             (list 't th)
                             (list 'g gu)
                             (list 'c cy)))
        (incf-base b)))))

(defun prefixp (x y)
  (cond ((null x) t)
        ((null y) nil)
        (t (if (equal (first x) (first y))
               (prefixp (rest x) (rest y))))))

(defun appearsp (x y)
  (unless (null y)
    (or (prefixp x y) (appearsp x (rest y)))))

;; Too clever? Streams are good and fun.
(defun coverp (x y)
  (let ((cycle (copy-list x)))
    (setf (cdr (last cycle)) cycle)
    (prefixp y cycle)))

(defun prefix (n strand)
  (cond ((or (null strand) (zerop n)) nil)
        (t (cons (first strand)
                 (prefix (- n 1) (rest strand))))))

(defun kernel (strand)
  (do* ((i 1 (+ i 1))
        (p (prefix i strand) (prefix i strand)))
       ((coverp p strand) p)))

(defun draw-dna (strand)
  (labels ((spaces (n)
             (dotimes (i n)
               (format t " ")))
           (print-dashes (n)
             (dotimes (i n)
               (format t "-"))
             (format t "~%"))
           (print-chars (cs)
             (spaces 2)
             (dolist (c cs)
               (format t "~A" c)
               (spaces 4))
             (spaces 2)
             (format t "~%")))
    (let ((len (* 5 (length strand)))
          (comps (complement-strand strand))
          (stops (mapcar #'(lambda (x) ".") strand))
          (bangs (mapcar #'(lambda (x) "!") strand)))
      (print-dashes len)
      (print-chars bangs)
      (print-chars strand)
      (print-chars stops)
      (print-chars stops)
      (print-chars comps)
      (print-chars bangs)
      (print-dashes len))))